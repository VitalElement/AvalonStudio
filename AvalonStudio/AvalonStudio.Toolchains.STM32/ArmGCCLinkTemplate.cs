// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace AvalonStudio.Toolchains.STM32
{
	/// <summary>
	///     Class to produce the template output
	/// </summary>
#line 1 "G:\development\repos\AvalonStudio\AvalonStudio\AvalonStudio.Toolchains.STM32\ArmGCCLinkTemplate.tt"
	[GeneratedCode("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
	public partial class ArmGCCLinkTemplate : ArmGCCLinkTemplateBase
	{
		/// <summary>
		///     Create the template output
		/// </summary>
		public virtual string TransformText()
		{
			Write("/**\r\n *\t\tVital Element Studios - LinkerScript\r\n *\r\n **/\r\n \r\nOUTPUT_FORMAT (\"elf32" +
			      "-littlearm\", \"elf32-bigarm\", \"elf32-littlearm\")\r\n\r\nMEMORY\r\n{\r\n\tFLASH (rx)  : ORI" +
			      "GIN = ");

#line 15 "G:\development\repos\AvalonStudio\AvalonStudio\AvalonStudio.Toolchains.STM32\ArmGCCLinkTemplate.tt"
			Write(ToStringHelper.ToStringWithCulture(string.Format("0x{0:X8}", linkSettings.InRom1Start)));

#line default
#line hidden
			Write(", LENGTH = ");

#line 15 "G:\development\repos\AvalonStudio\AvalonStudio\AvalonStudio.Toolchains.STM32\ArmGCCLinkTemplate.tt"
			Write(ToStringHelper.ToStringWithCulture(string.Format("0x{0:X8}", linkSettings.InRom1Size)));

#line default
#line hidden
			Write("\r\n\tRAM (rwx) : ORIGIN = ");

#line 16 "G:\development\repos\AvalonStudio\AvalonStudio\AvalonStudio.Toolchains.STM32\ArmGCCLinkTemplate.tt"
			Write(ToStringHelper.ToStringWithCulture(string.Format("0x{0:X8}", linkSettings.InRam1Start)));

#line default
#line hidden
			Write(", LENGTH = ");

#line 16 "G:\development\repos\AvalonStudio\AvalonStudio\AvalonStudio.Toolchains.STM32\ArmGCCLinkTemplate.tt"
			Write(ToStringHelper.ToStringWithCulture(string.Format("0x{0:X8}", linkSettings.InRam1Size)));

#line default
#line hidden
			Write("\r\n\tRAM1 (rwx) : ORIGIN = 0xD0000000, LENGTH = 0x00800000\r\n}\r\n\r\n_eram = ");

#line 20 "G:\development\repos\AvalonStudio\AvalonStudio\AvalonStudio.Toolchains.STM32\ArmGCCLinkTemplate.tt"
			Write(ToStringHelper.ToStringWithCulture(string.Format("0x{0:X8}", linkSettings.InRam1Start)));

#line default
#line hidden
			Write(" + ");

#line 20 "G:\development\repos\AvalonStudio\AvalonStudio\AvalonStudio.Toolchains.STM32\ArmGCCLinkTemplate.tt"
			Write(ToStringHelper.ToStringWithCulture(string.Format("0x{0:X8}", linkSettings.InRam1Size)));

#line default
#line hidden
			Write(
				";\r\n\r\nSECTIONS\r\n{\r\n\t.text :\r\n\t{\r\n\t\tKEEP(*(.interrupt_vector))\r\n\t\t*(.text*)\r\n\t\t\r\n\t\t" +
				"KEEP(*(.init))\r\n\t\tKEEP(*(.fini))\r\n\t\t\r\n\t\t/* .ctors */\r\n\t\t*crtbegin.o(.ctors)\r\n\t\t*" +
				"crtbegin?.o(.ctors)\r\n\t\t*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)\r\n\t\t*(SORT(.c" +
				"tors.*))\r\n\t\t*(.ctors)\r\n\t\t\r\n\t\t/* .dtors */\r\n\t\t*crtbegin.o(.dtors)\r\n\t\t*crtbegin?.o" +
				"(.dtors)\r\n\t\t*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)\r\n\t\t*(SORT(.dtors.*))\r\n\t" +
				"\t*(.dtors)\r\n\t\t\r\n\t\t*(.rodata*)\r\n\t\t\r\n\t\tKEEP(*(.eh_fram e*))\r\n\t} > FLASH\r\n    \r\n   " +
				" \t.ARM.extab : \r\n\t{\r\n\t\t*(.ARM.extab* .gnu.linkonce.armextab.*)\r\n\t} > FLASH \r\n\t\r\n" +
				"\t__exidx_start = .;\r\n\t.ARM.exidx :\r\n\t{\r\n\t\t*(.ARM.exidx* .gnu.linkonce.armexidx.*" +
				")\r\n\t} > FLASH \r\n\t__exidx_end = .;\r\n\t__etext = .;\r\n\t\r\n    _data_flash = .;\r\n    \r" +
				"\n    .data : AT ( _data_flash )\r\n\t{\r\n\t\t. = ALIGN(4);\r\n\t\t_data_begin = .;\r\n\t\t*(vt" +
				"able)\r\n\t\t*(.data)\r\n\t\t*(.data*)\r\n\r\n\t\t        . = ALIGN(4);\r\n        /* preinit da" +
				"ta */\r\n        PROVIDE_HIDDEN (__preinit_array_start = .);\r\n        KEEP(*(.prei" +
				"nit_array))\r\n        PROVIDE_HIDDEN (__preinit_array_end = .);\r\n \r\n        . = A" +
				"LIGN(4);\r\n        /* init data */\r\n        PROVIDE_HIDDEN (__init_array_start = " +
				".);\r\n        KEEP(*(SORT(.init_array.*)))\r\n        KEEP(*(.init_array))\r\n       " +
				" PROVIDE_HIDDEN (__init_array_end = .);\r\n \r\n \r\n        . = ALIGN(4);\r\n        /*" +
				" finit data */\r\n        PROVIDE_HIDDEN (__fini_array_start = .);\r\n        KEEP(*" +
				"(SORT(.fini_array.*)))\r\n        KEEP(*(.fini_array))\r\n        PROVIDE_HIDDEN (__" +
				"fini_array_end = .);\r\n \r\n        KEEP(*(.jcr*))\r\n\r\n\t\t. = ALIGN(4);\r\n\t\t_data_end " +
				"= .;\r\n\t} > RAM\r\n    \r\n    .bss :\r\n\t{\r\n\t\t_bss_begin = .;\r\n\t\t__bss_start__ = _bss_" +
				"begin;\r\n\t\t*(.bss)\r\n\t\t*(.bss*)\r\n\t\t*(COMMON)\r\n\t\t. = ALIGN(4);\r\n\t\t_bss_end = .;\r\n\t\t" +
				"__bss_end__ = _bss_end;\r\n\t} > RAM\r\n}\r\n\r\n/* end of allocated ram _end */\r\nPROVIDE" +
				"( _HEAP_START = _bss_end );\r\n\r\n/* end of the heap -> align 8 byte */ \r\nPROVIDE (" +
				" _HEAP_END = ALIGN(ORIGIN(RAM) + LENGTH(RAM) ,8) );\r\n\r\n\r\nENTRY(Default_Reset_Han" +
				"dler);\r\n");
			return GenerationEnvironment.ToString();
		}
	}

#line default
#line hidden

	#region Base class

	/// <summary>
	///     Base class for this transformation
	/// </summary>
	[GeneratedCode("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
	public class ArmGCCLinkTemplateBase
	{
		#region Fields

		private StringBuilder generationEnvironmentField;
		private CompilerErrorCollection errorsField;
		private List<int> indentLengthsField;
		private bool endsWithNewline;

		#endregion

		#region Properties

		/// <summary>
		///     The string builder that generation-time code is using to assemble generated output
		/// </summary>
		protected StringBuilder GenerationEnvironment
		{
			get
			{
				if (generationEnvironmentField == null)
				{
					generationEnvironmentField = new StringBuilder();
				}
				return generationEnvironmentField;
			}
			set { generationEnvironmentField = value; }
		}

		/// <summary>
		///     The error collection for the generation process
		/// </summary>
		public CompilerErrorCollection Errors
		{
			get
			{
				if (errorsField == null)
				{
					errorsField = new CompilerErrorCollection();
				}
				return errorsField;
			}
		}

		/// <summary>
		///     A list of the lengths of each indent that was added with PushIndent
		/// </summary>
		private List<int> indentLengths
		{
			get
			{
				if (indentLengthsField == null)
				{
					indentLengthsField = new List<int>();
				}
				return indentLengthsField;
			}
		}

		/// <summary>
		///     Gets the current indent we use when adding lines to the output
		/// </summary>
		public string CurrentIndent { get; private set; } = "";

		/// <summary>
		///     Current transformation session
		/// </summary>
		public virtual IDictionary<string, object> Session { get; set; }

		#endregion

		#region Transform-time helpers

		/// <summary>
		///     Write text directly into the generated output
		/// </summary>
		public void Write(string textToAppend)
		{
			if (string.IsNullOrEmpty(textToAppend))
			{
				return;
			}
			// If we're starting off, or if the previous text ended with a newline,
			// we have to append the current indent first.
			if ((GenerationEnvironment.Length == 0)
			    || endsWithNewline)
			{
				GenerationEnvironment.Append(CurrentIndent);
				endsWithNewline = false;
			}
			// Check if the current text ends with a newline
			if (textToAppend.EndsWith(Environment.NewLine, StringComparison.CurrentCulture))
			{
				endsWithNewline = true;
			}
			// This is an optimization. If the current indent is "", then we don't have to do any
			// of the more complex stuff further down.
			if (CurrentIndent.Length == 0)
			{
				GenerationEnvironment.Append(textToAppend);
				return;
			}
			// Everywhere there is a newline in the text, add an indent after it
			textToAppend = textToAppend.Replace(Environment.NewLine, Environment.NewLine + CurrentIndent);
			// If the text ends with a newline, then we should strip off the indent added at the very end
			// because the appropriate indent will be added when the next time Write() is called
			if (endsWithNewline)
			{
				GenerationEnvironment.Append(textToAppend, 0, textToAppend.Length - CurrentIndent.Length);
			}
			else
			{
				GenerationEnvironment.Append(textToAppend);
			}
		}

		/// <summary>
		///     Write text directly into the generated output
		/// </summary>
		public void WriteLine(string textToAppend)
		{
			Write(textToAppend);
			GenerationEnvironment.AppendLine();
			endsWithNewline = true;
		}

		/// <summary>
		///     Write formatted text directly into the generated output
		/// </summary>
		public void Write(string format, params object[] args)
		{
			Write(string.Format(CultureInfo.CurrentCulture, format, args));
		}

		/// <summary>
		///     Write formatted text directly into the generated output
		/// </summary>
		public void WriteLine(string format, params object[] args)
		{
			WriteLine(string.Format(CultureInfo.CurrentCulture, format, args));
		}

		/// <summary>
		///     Raise an error
		/// </summary>
		public void Error(string message)
		{
			var error = new CompilerError();
			error.ErrorText = message;
			Errors.Add(error);
		}

		/// <summary>
		///     Raise a warning
		/// </summary>
		public void Warning(string message)
		{
			var error = new CompilerError();
			error.ErrorText = message;
			error.IsWarning = true;
			Errors.Add(error);
		}

		/// <summary>
		///     Increase the indent
		/// </summary>
		public void PushIndent(string indent)
		{
			if (indent == null)
			{
				throw new ArgumentNullException("indent");
			}
			CurrentIndent = CurrentIndent + indent;
			indentLengths.Add(indent.Length);
		}

		/// <summary>
		///     Remove the last indent that was added with PushIndent
		/// </summary>
		public string PopIndent()
		{
			var returnValue = "";
			if (indentLengths.Count > 0)
			{
				var indentLength = indentLengths[indentLengths.Count - 1];
				indentLengths.RemoveAt(indentLengths.Count - 1);
				if (indentLength > 0)
				{
					returnValue = CurrentIndent.Substring(CurrentIndent.Length - indentLength);
					CurrentIndent = CurrentIndent.Remove(CurrentIndent.Length - indentLength);
				}
			}
			return returnValue;
		}

		/// <summary>
		///     Remove any indentation
		/// </summary>
		public void ClearIndent()
		{
			indentLengths.Clear();
			CurrentIndent = "";
		}

		#endregion

		#region ToString Helpers

		/// <summary>
		///     Utility class to produce culture-oriented representation of an object as a string.
		/// </summary>
		public class ToStringInstanceHelper
		{
			private IFormatProvider formatProviderField = CultureInfo.InvariantCulture;

			/// <summary>
			///     Gets or sets format provider to be used by ToStringWithCulture method.
			/// </summary>
			public IFormatProvider FormatProvider
			{
				get { return formatProviderField; }
				set
				{
					if (value != null)
					{
						formatProviderField = value;
					}
				}
			}

			/// <summary>
			///     This is called from the compile/run appdomain to convert objects within an expression block to a string
			/// </summary>
			public string ToStringWithCulture(object objectToConvert)
			{
				if (objectToConvert == null)
				{
					throw new ArgumentNullException("objectToConvert");
				}
				var t = objectToConvert.GetType();
				var method = t.GetMethod("ToString", new[]
				{
					typeof (IFormatProvider)
				});
				if (method == null)
				{
					return objectToConvert.ToString();
				}
				return (string) method.Invoke(objectToConvert, new object[]
				{
					formatProviderField
				});
			}
		}

		/// <summary>
		///     Helper to produce culture-oriented representation of an object as a string
		/// </summary>
		public ToStringInstanceHelper ToStringHelper { get; } = new ToStringInstanceHelper();

		#endregion
	}

	#endregion
}